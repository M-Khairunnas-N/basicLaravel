1. laravel using MVC paradigm

2. public/index.php is entry point for our program:
    in index we execute: laravel, composer, bootstrap, kernel, and request

3. kernel in laravel have 2 kernel:
    a. HTTP kernel serve HTTP or web request, first request accepted in
    public/index.php and continue to Kernel class in app/Http folder.
    Bootstrapping in kernel is a Core logic process so that we can receive
    request from Web and handling that request, so we can respond, but this
    just load service provider class in app/providers folder
    b. Console kernel to serve console request.

4. Service provider that do bootstrapping for all component in laravel like:
    database, queue, validation, routing, etc. This process is like
    init.php in our first program in "Project_Tatib" third semester IT
    Polinema. There is a Class in app/Providers that important for basic,
    that is RouteServiceProvides, this class handling routing from our URL
    like what controller and method that we execute for some feature in web

5. this some request cycle: Request->public/index.php->Kernel(if HTTP
    request accepted in HTTP kernel usually for web application, and if
    console request or console application accepted in app/console/Kernel
    .php or console kernel)->Service_Provider(do multiple bootstrapping for
    all component)->if Routing we use RouteServiceProviders
    Class->app/routes folder for more specific routing

6. in laravel there are 2 Testing method:
    a.Unit test: unit testing is test that focus on testing small unit like
    function, method, class, and other component. This test is made to our
    unit code is running in isolation environment without dependency to
    other unit or outside environment. use PHPUnit\Framework\TestCase
    and this test much faster than integration because we
    haven't loaded our laravel. You can use artisan command to make Unit
    Test: "php artisan make:test NameUnitTest --unit".
    b. integration test: test that focus in interaction between unit in some
    big accumulation unit, like interaction view, controller and model
    use Illuminate\Foundation\Testing\TestCase to make integration test.
    This test is much easy to access our laravel component like Database,
    Controller, and other compare to Unit Test also if you use laravel
    feature u must use integration test. To make integration test u can use
    artisan command: "php artisan make:test NameIntegrationTest".
    If you want to run all test
    you can use artisan command: "php artisan test"
    Notes: in function name in our testing class must prefix with test

7. environment setting in laravel much easier with help .env file in our
    project, you can add, edit, and delete manually in there without setting
    environment variable manually in our system.Laravel in function env()
    or you can use Env::get() have default value if our env var hadn't
    existed, here some example:
    env(key, default) => env("THIS_KEY", "DEFAULT")

8. Application environment: sometimes we want to set our application
    running in which environment like: local, development, staging, Qa or
    Production, so in laravel you can change that by edit APP_ENV in .env.
    Note: if you make UnitTest or Integration Test, and want to check your
    application environment, laravel will override your APP_ENV to "testing"
    in file phpunit.xml, this is code: <env name="APP_ENV" value="testing"/>
    If you want to know which app env you code running you can use function
    "App::environment() or App::environment([value1, value2]
    (this for multiple value check)"; so you haven't used function
    env("APP_ENV") to check that

9. Configuration: Environment variable in .env used for configuration that
    always change or frequent to change and integrate in environment
    variable in OS; but laravel also support configuration setting with
    PHP code, this configuration usually used when configuration haven't
    frequently change and this usually same with other app location when
    running, this type configuration is saved in config folder in laravel
    and prefix for this configuration start with name php file within there
    To make config file, you can make file .php in config folder and inside
    that you can return associative array and to receive configuration, you
    can use function => config(key, default)
    with key is "prefix(or nameFile).arrayKey(if nested array you can use .
    like: example.author.first)"
    Note: if you make some file in config folder, try to make file name
    with lowercase

    configuration cache: sometimes we had crated to many config files
    that result in laravel must read all that when we get config, in
    development this seems not big problem, but if our program enter
    production stage, this will make our program became slow, so in laravel
    there is feature for caching our configuration that make our
    configuration became one file, so laravel read process will become much
    faster, because data will be loaded when application is started
    In order to make configuration cache you can type artisan command:
    "php artisan config:cache", but you must do this when production
    deployment process, because when you application's in development stage
    configuration will frequently be changed and once configuration has
    been cached, your application's config that new added will not be used
    and your .env file will not be loaded by the framework during request
    or artisan command and env functions just
    return external system level environment variables and sometimes
    env() function will not work, so for this reason you should called env
    value from config() function by configuration
    file, or you can purged your cached configuration by artisan command
    "php artisan config:clear"

10. Dependencies injection: is some technic that object can receive other
    object or dependency, so those object that receive other object require
    that object to be functional, this make object depend on other object
    which sometimes not good enough, but if your program must require that
    , more recommended if your dependency injection or process insert
    foreign object is from constructor. In laravel we haven't made
    dependency injection manually, because in laravel there is feature that
    can make, maintain, and manage dependency injection in automatically
    way, this feature is Service Container, that represented in Application
    class, but we haven't made instance manually from that class, because
    if you look on public/index.php file, there is $app object that
    defined instance our Application class, so you can use that instance
    to access methods like service container and other services. In
    service container specifically, you haven't made dependency instance
    that use by dependent with 'new' key again, but accessed by
    $classInstance = $app->make(className::class), some notes that if you
    make dependency instance from those way, each class instance you make
    always new and not same object again, also make function in Application
    class cannot process complex class like constructor from dependency
    require parameter, so you can use bind(key, closure) function, in this
    function you can just return array inside closure with value is
    argument that needed for constructor, so when you call make function
    to get dependency instance, automatically bind function is called
    , but same like make function, bind function will called each time make
    function is called, so instance isn't same
    Notes: function like bind(key, closure) and make(key) function isn't
    limited in dependencies instance maker, but you can make all class
    instance that available in you laravel

    A. Singleton method: if before in Application class that instantiate in
     $app variable and have function like bind(key, closure) that return
     instance from our class, but instance always new, so laravel have
     function that return same object even if you called make(key) function
     again and again, this function is singleton(key, closure) function

    B.instance method: if before in Application class that instantiate in
     $app variable and have function like singleton(key, closure) return
     instance from our class, but instance always same, different with that
     instance(key, object) function haven't required closure, but you can
     pass object in parameter. Functionality this function is same like
     singleton(key, closure) function and when you call make(key) function
     again and again, instance that returned is the same object

Notes for bind(key, closure), singleton(key, closure) , and instance(key,
    object) function: if you call make(key) function with key is dependent
    class, laravel with ServiceContainer will automatically search
    dependency class that available and pass the requirements for our
    dependent

    C.Dependency injection in closure: we can use method in Application
    class that specifically in ServiceContainer by use $app instance
    inside closure. This way can be used to pass $app in parameter like
    method bind, instance, and singleton that we used before

    D.Binding interface on class: like I said before, u can use methods
     existing in Application class from
     Illuminate\Foundation\Application or
     in Illuminate\Support\Facade if that method is available like
     bind(interface, class), bind(interface, closure),
     singleton(interface, class), and singleton(interface, closure)
     , with closure function return implemented class(object or instance)
     that extend interface

11. Service container:
    A. Zero Configuration Resolution: if a class has no dependencies or
    only depends on other concrete classes(not interfaces), the container
    doesn't need to be instructed on how to resolve that class like this:
    <?php

        class Service
        {
            // ...
        }
    ?>

    <?php
        Route::get('/', function (Service $service) {
            die($service::class);
        });
    ?>
    this example in routes/web.php file(below). In this example dependency
    injection is resolved by Route::get() function, and many classes will
    be writing when building a laravel application automatically receive
    their dependencies via container, including controllers, event
    listeners, middleware and more.Additionally, you might type-hint the
    dependencies in the handle method of queued jobs that make those task
    faster in response.
    Thanks to zero configuration resolution, you will often type-hint
    dependencies on routes, controllers, event listeners, and elsewhere
    without ever manually interacting with the container. For example, you
    might type-hint the Illuminate\Http\Request object on your route
    definition so that you can easily access the current request. Even
    though we never have to interact with the container to write this
    code, it is managing the injection of these dependencies behind the
    scenes:

        use Illuminate\Http\Request;

        Route::get('/', function (Request $request) {
            // ...
        });

    In many cases, thanks to automatic dependency injection and facades,
    you can build Laravel applications without ever manually binding or
    resolving anything from the container. So, when would you ever
    manually interact with the container? Let's examine two situations.
    First, if you write a class that implements an interface, and you wish
    to type-hint that interface on a route or class constructor, you must
    tell the container how to resolve that interface. Secondly, if you are
    writing a Laravel package that you plan to share with other Laravel
    developers, you may need to bind your package's services into the
    container.

    B.other than Service containers that provide by
     Illuminate\Foundation\Application you can use
     Illuminate\Support\Facades\App
     Facades in Laravel provide a “static” interface to classes that are
     available in the application’s service container. They serve as
     “static proxies” to underlying classes in the service container,
     providing the benefit of a terse, expressive syntax while maintaining
     more testability and flexibility than traditional static methods.
     When you access a facade, Laravel will get the responsible object
     from the service container and pass the data to this object

    C.Service Providers: if service container is a place where your
     service classes are registered, service provider is a central place
     that bootstrapping all laravel applications and manage to register
     all service class to service container and in laravel Service
     Provider are places in App/Providers directory. Each Service provider
     have default method register() and boot() functions. register()
     function is responsible for registering you services(dependencies)
     , notes: you haven't to add code to register() function other than
     registering dependencies or else you will face not found dependencies.
     boot() function is responsible other code that register services.
     You can make Service Provider automatically with artisan command:
     "php artisan make:provider NameServiceProvider"
     When we make Service Provider, in default your service provider hadn't
     load by laravel, so in order to make laravel know about your service
     provider, you can add in config/app.php file, in there had key
     provider that had class-class Service Provider run by laravel, you
     can add in array key "providers" in application services block
     The bindings and singletons Properties
     If your service provider registers many simple bindings, you may wish
     to use the bindings and singletons properties instead of manually
     registering each
     container binding. When the service provider is loaded by the
     framework, it will automatically check for these properties and
     register their bindings

     D. Deferred Service Provider: if your service provider is only
      registering binding in service container, you may choose to
      defer(load provider only when used) until one of the registered
      bindings is actually needed. Deferring the loading of such a provider
      will improve the performance of your application, since it's not
      loaded from the filesystem on every request
      Laravel compiles and stores a list of all it's services supplied by
      deferred service provider, along with the name of it's service
      provider class. Then , only when you attempt to resolve one of
      these services does laravel load the service provider
      To defer the loading of a provider, implement this contract:
      'Illuminate\Contracts\Support\DeferrableProvider' interface and
      define a provides() method. The provides() method should return
      the service container bindings registered by the service provider
      You can change your service provider and make compiled services
      change by:
      1. artisan command: 'php artisan clear-compiled'
      2. do some process stuff like running you application
       : 'php artisan serve' like that

12. Facades: before when interact with features in laravel we use
    dependency injection, but sometimes, there are cases when we haven't
    retrieved application object like when we make class that isn't
    laravel feature(
        before we create class in test/Feature and Providers
        folder which those folder is laravel feature, so we can use $app
        or Application object, but what if we make class that hadn't
        laravel feature?, in order to access that in static way you can
        use facades
    ),
    so facades can be used. Facades provides static access
    through features in service container or Application class and in
    summary laravel facades provide access to almost all of laravel
    features, All of Laravel's facades are defined in the
    Illuminate\Support\Facades namespace. So, we can easily access a
    facade, for example:

    <?php
        use Illuminate\Support\Facades\Cache;
        use Illuminate\Support\Facades\Route;

        Route::get('/cache', function () {
          return Cache::get('key');
        });
    ?>

    But you must use facades just when your needed, like when you can use
    dependencies injection, always use dependencies injection, because use
    to many facades will make your unconsciousness that your class had
    much dependency to use, and you haven't known that and the primary
    danger of facades is class "scope creep". Since facades are so easy to
    use and do not require injection, it can be easy to let your classes
    continue to grow and use many facades in a single class. Using
    dependency injection, this potential is mitigated by the visual
    feedback a large constructor gives you that your class is growing too
    large. So, when using facades, pay special attention to the size of
    your class so that its scope of responsibility stays narrow. If your
    class is getting too large, consider splitting it into multiple
    smaller classes, but if you make dependencies injection manually, you
    can see how many parameters that we had to pass in constructor.

    A. Facades vs. Dependency Injection
     One of the primary benefits of dependency injection is the ability to
     swap implementations of the injected class. This is useful during
     testing since you can inject a mock or stub and assert that various
     methods were called on the stub.
     Typically, it would not be possible to mock or stub a truly static
     class method. However, since facades use dynamic methods to proxy
     method calls to objects resolved from the service container, we
     actually can test facades just as we would test an injected class
     instance. For example, given the following route:

     <?php
       use Illuminate\Support\Facades\Cache;

       Route::get('/cache', function () {
           return Cache::get('key');
       });
     ?>

     Using Laravel's facade testing methods, we can write the following
     test to verify that the Cache::get method was called with the
     argument we expected:

     <?php
       use Illuminate\Support\Facades\Cache;

       /**
        * A basic functional test example.
        */
       public function test_basic_example(): void
       {
           Cache::shouldReceive('get')
                ->with('key')
                ->andReturn('value');

           $response = $this->get('/cache');

           $response->assertSee('value');
       }
     ?>

    B.Facades vs. Helper Functions: in facades there is Helper function
     this different with Helper functions that those functions not
     collected in one class like facades. Before we use Helper functions
     like config() or env(), this provide more easy to use
     helper, but some function compare to facades, helper in facades is
     more simple by code.You can mix helper function and facades, because
     Helper functions are globally and became complement to facades,
     Laravel offers a variety of global "helper functions" that make it
     even easier to interact with common Laravel features. Some of the
     common helper functions you may interact with are view, response,
     url, config, and more.
     Each helper function offered by Laravel is documented with
     their corresponding feature; however, a complete list is available
     within the dedicated helper documentation.
     For example, instead of using the Illuminate\Support\Facades\Response
     facade to generate a JSON response, we may simply use the response
     function. Because helper functions are globally available, you do not
     need to import any classes in order to use them:

     instead using this:
     <?php
          use Illuminate\Support\Facades\Response;

          Route::get('/users', function () {
              return Response::json([
                  // ...
              ]);
          });
     ?>

     you can use helper functions that global:
      <?php
          Route::get('/users', function () {
              return response()->json([
                  // ...
              ]);
          });
      ?>

      For example again, this facade call and helper call are equivalent:

      Facade call:
      return Illuminate\Support\Facades\View::make('profile');

      Helper call:
      return view('profile');

      There is absolutely no practical difference between facades and
      helper functions. When using helper functions, you may still test
      them exactly as you would the corresponding facade. For example,
      given the following route:

      <?php
          Route::get('/cache', function () {
              return cache('key');
          });
      ?>

      The cache helper is going to call the get method on the class
      underlying the Cache facade. So, even though we are using the helper
      function, we can write the following test to verify that the method
      was called with the argument we expected:

      <?php
          use Illuminate\Support\Facades\Cache;

          /**
           * A basic functional test example.
           */
          public function test_basic_example(): void
          {
              Cache::shouldReceive('get')
                   ->with('key')
                   ->andReturn('value');

              $response = $this->get('/cache');

              $response->assertSee('value');
          }
      ?>

      C. How facade works: in laravel applications, facades is a class that
       provides access to objects dependency from the service container.
       This machinery that makes this work is in the Facade class, also
       many helper functions that called by facade or called in static way
       also extend Facade class, so laravel facades and any custom facades
       you create, will extend base 'Illuminate\Support\Facades\Facade'
       In Facade class have a method __callStatic() that uses like magic
       method or meta programming that will call method in dependency in
       Service Container, although we call static method we pass in
       static way like 'Route::get()', this will call get method in Route
       dependency in service container
       By glancing at this code, one might assume that the static get method is being called on the Cache class:

       <?php

           namespace App\Http\Controllers;

           use App\Http\Controllers\Controller;
           use Illuminate\Support\Facades\Cache;
           use Illuminate\View\View;

           class UserController extends Controller
           {
               /**
                * Show the profile for the given user.
                */
               public function showProfile(string $id): View
               {
                   $user = Cache::get('user:'.$id);

                   return view('profile', ['user' => $user]);
               }
           }
       ?>

       Notice that near the top of the file we are "importing" the Cache
       facade. This facade serves as a proxy for accessing the underlying
       implementation of the Illuminate\Contracts\Cache\Factory interface.
       Any calls we make using the facade will be passed to the underlying
       instance of Laravel's cache service.

       If we look at that Illuminate\Support\Facades\Cache class, you'll
       see that there is no static method get:

       <?php
           class Cache extends Facade
           {
               /**
                * Get the registered name of the component.
                */
               protected static function getFacadeAccessor(): string
               {
                   return 'cache';
               }
           }
       ?>

       Instead, the Cache facade extends the base Facade class and defines
       the method getFacadeAccessor(). This method's job is to return the
       name of a service container binding. When a user references any
       static method on the Cache facade, Laravel resolves the cache
       binding from the service container and runs the requested method
       (in this case, get) against that object.
