1. laravel using MVC paradigm

2. public/index.php is entry point for our program:
    in index we execute: laravel, composer, bootstrap, kernel, and request

3. kernel in laravel have 2 kernel:
    a. HTTP kernel serve HTTP or web request, first request accepted in
    public/index.php and continue to Kernel class in app/Http folder.
    Bootstrapping in kernel is a Core logic process so that we can receive
    request from Web and handling that request, so we can respond, but this
    just load service provider class in app/providers folder
    b. Console kernel to serve console request.

4. Service provider that do bootstrapping for all component in laravel like:
    database, queue, validation, routing, etc. This process is like
    init.php in our first program in "Project_Tatib" third semester IT
    Polinema. There is a Class in app/Providers that important for basic,
    that is RouteServiceProvides, this class handling routing from our URL
    like what controller and method that we execute for some feature in web

5. this some request cycle: Request->public/index.php->Kernel(if HTTP
    request accepted in HTTP kernel usually for web application, and if
    console request or console application accepted in app/console/Kernel
    .php or console kernel)->Service_Provider(do multiple bootstrapping for
    all component)->if Routing we use RouteServiceProviders
    Class->app/routes folder for more specific routing

6. in laravel there are 2 Testing method:
    a.Unit test: unit testing is test that focus on testing small unit like
    function, method, class, and other component. This test is made to our
    unit code is running in isolation environment without dependency to
    other unit or outside environment. use PHPUnit\Framework\TestCase
    and this test much faster than integration because we
    haven't loaded our laravel. You can use artisan command to make Unit
    Test: "php artisan make:test NameUnitTest --unit".
    b. integration test: test that focus in interaction between unit in some
    big accumulation unit, like interaction view, controller and model
    use Illuminate\Foundation\Testing\TestCase to make integration test.
    This test is much easy to access our laravel component like Database,
    Controller, and other compare to Unit Test also if you use laravel
    feature u must use integration test. To make integration test u can use
    artisan command: "php artisan make:test NameIntegrationTest".
    If you want to run all test
    you can use artisan command: "php artisan test"
    Notes: in function name in our testing class must prefix with test

7. environment setting in laravel much easier with help .env file in our
    project, you can add, edit, and delete manually in there without setting
    environment variable manually in our system.Laravel in function env()
    or you can use Env::get() have default value if our env var hadn't
    existed, here some example:
    env(key, default) => env("THIS_KEY", "DEFAULT")

8. Application environment: sometimes we want to set our application
    running in which environment like: local, development, staging, Qa or
    Production, so in laravel you can change that by edit APP_ENV in .env.
    Note: if you make UnitTest or Integration Test, and want to check your
    application environment, laravel will override your APP_ENV to "testing"
    in file phpunit.xml, this is code: <env name="APP_ENV" value="testing"/>
    If you want to know which app env you code running you can use function
    "App::environment() or App::environment([value1, value2]
    (this for multiple value check)"; so you haven't used function
    env("APP_ENV") to check that

9. Configuration: Environment variable in .env used for configuration that
    always change or frequent to change and integrate in environment
    variable in OS; but laravel also support configuration setting with
    PHP code, this configuration usually used when configuration haven't
    frequently change and this usually same with other app location when
    running, this type configuration is saved in config folder in laravel
    and prefix for this configuration start with name php file within there
    To make config file, you can make file .php in config folder and inside
    that you can return associative array and to receive configuration, you
    can use function => config(key, default)
    with key is "prefix(or nameFile).arrayKey(if nested array you can use .
    like: example.author.first)"
    Note: if you make some file in config folder, try to make file name
    with lowercase

    configuration cache: sometimes we had crated to many config files
    that result in laravel must read all that when we get config, in
    development this seems not big problem, but if our program enter
    production stage, this will make our program became slow, so in laravel
    there is feature for caching our configuration that make our
    configuration became one file, so laravel read process will become much
    faster, because data will be loaded when application is started
    In order to make configuration cache you can type artisan command:
    "php artisan config:cache", but you must do this when production
    deployment process, because when you application's in development stage
    configuration will frequently be changed and once configuration has
    been cached, your application's config that new added will not be used
    and your .env file will not be loaded by the framework during request
    or artisan command and env functions just
    return external system level environment variables and sometimes
    env() function will not work, so for this reason you should called env
    value from config() function by configuration
    file, or you can purged your cached configuration by artisan command
    "php artisan config:clear"

10. Dependencies injection: is some technic that object can receive other
    object or dependency, so those object that receive other object require
    that object to be functional, this make object depend on other object
    which sometimes not good enough, but if your program must require that
    , more recommended if your dependency injection or process insert
    foreign object is from constructor. In laravel we haven't made
    dependency injection manually, because in laravel there is feature that
    can make, maintain, and manage dependency injection in automatically
    way, this feature is Service Container, that represented in Application
    class, but we haven't made instance manually from that class, because
    if you look on public/index.php file, there is $app object that
    defined instance our Application class, so you can use that instance
    to access methods like service container and other services. In
    service container specifically, you haven't made dependency instance
    that use by dependent with 'new' key again, but accessed by
    $classInstance = $app->make(className::class), some notes that if you
    make dependency instance from those way, each class instance you make
    always new and not same object again, also make function in Application
    class cannot process complex class like constructor from dependency
    require parameter, so you can use bind(key, closure) function, in this
    function you can just return array inside closure with value is
    argument that needed for constructor, so when you call make function
    to get dependency instance, automatically bind function is called
    , but same like make function, bind function will called each time make
    function is called, so instance isn't same
    Notes: function like bind(key, closure) and make(key) function isn't
    limited in dependencies instance maker, but you can make all class
    instance that available in you laravel

11. Singleton method: if before in Application class that instantiate in
    $app variable and have function like bind(key, closure) that return
    instance from our class, but instance always new, so laravel have
    function that return same object even if you called make(key) function
    again and again, this function is singleton(key, closure) function

12. instance method: if before in Application class that instantiate in
    $app variable and have function like singleton(key, closure) return
    instance from our class, but instance always same, different with that
    instance(key, object) function haven't required closure, but you can
    pass object in parameter. Functionality this function is same like
    singleton(key, closure) function and when you call make(key) function
    again and again, instance that returned is the same object

Notes for bind(key, closure), singleton(key, closure) , and instance(key,
    object) function: if you call make(key) function with key is dependent
    class, laravel with ServiceContainer will automatically search
    dependency class that available and pass the requirements for our
    dependent

13. Dependency injection in closure: we can use method in Application class
    that specifically in ServiceContainer by use $app instance inside
    closure. This way can be used to pass $app in parameter like method
    bind, instance, and singleton that we used before

14. Binding interface on class: like I said before, u can use methods
    existing in Application class from
    Illuminate\Foundation\Application or
    in Illuminate\Support\Facade if that method is available like
    bind(interface, class), bind(interface, closure),
    singleton(interface, class), and singleton(interface, closure)
    , with closure function return implemented class(object or instance)
    that extend interface

15. Service container:
    A. Zero Configuration Resolution: if a class has no dependencies or
    only depends on other concrete classes(not interfaces), the container
    doesn't need to be instructed on how to resolve that class like this:
    <?php

        class Service
        {
            // ...
        }
    ?>

    <?php5
        Route::get('/', function (Service $service) {
            die($service::class);
        });
    ?>
    this example in routes/web.php file(below). In this example dependency
    injection is resolved by Route::get() function, and many classes will
    be writing when building a laravel application automatically receive
    their dependencies via container, including controllers, event
    listeners, middleware and more.Additionally, you might type-hint the
    dependencies in the handle method of queued jobs that make those task
    faster in response.
    Thanks to zero configuration resolution, you will often type-hint
    dependencies on routes, controllers, event listeners, and elsewhere
    without ever manually interacting with the container. For example, you
    might type-hint the Illuminate\Http\Request object on your route
    definition so that you can easily access the current request. Even
    though we never have to interact with the container to write this
    code, it is managing the injection of these dependencies behind the
    scenes:

        use Illuminate\Http\Request;

        Route::get('/', function (Request $request) {
            // ...
        });

    In many cases, thanks to automatic dependency injection and facades,
    you can build Laravel applications without ever manually binding or
    resolving anything from the container. So, when would you ever
    manually interact with the container? Let's examine two situations.
    First, if you write a class that implements an interface and you wish
    to type-hint that interface on a route or class constructor, you must
    tell the container how to resolve that interface. Secondly, if you are
    writing a Laravel package that you plan to share with other Laravel
    developers, you may need to bind your package's services into the
    container.

    B.other than Service containers that provide by
     Illuminate\Foundation\Application you can use
     Illuminate\Support\Facades\App
     Facades in Laravel provide a “static” interface to classes that are
     available in the application’s service container. They serve as
     “static proxies” to underlying classes in the service container,
     providing the benefit of a terse, expressive syntax while maintaining
     more testability and flexibility than traditional static methods.
     When you access a facade, Laravel will get the responsible object
     from the service container and pass the data to this object

    C.Service Providers: if service container is a place where your
     service classes are registered, service provider is a central place
     that bootstrapping all laravel applications and manage to register
     all service class to service container and in laravel Service
     Provider are places in App/Providers directory. Each Service provider
     have default method register() and boot() functions. register()
     function is responsible for registering you services(dependencies)
     , notes: you haven't to add code to register() function other than
     registering dependencies or else you will face not found dependencies.
     boot() function is responsible other code that register services.
     You can make Service Provider automatically with artisan command:
     "php artisan make:provider NameServiceProvider"
     When we make Service Provider, in default your service provider hadn't
     load by laravel, so in order to make laravel know about your service
     provider, you can add in config/app.php file, in there had key
     provider that had class-class Service Provider run by laravel, you
     can add in array key "providers" in application services block
     The bindings and singletons Properties
     If your service provider registers many simple bindings, you may wish
     to use the bindings and singletons properties instead of manually
     registering each
     container binding. When the service provider is loaded by the
     framework, it will automatically check for these properties and
     register their bindings

     D. Deferred Service Provider: if your service provider is only
      registering binding in service container, you may choose to
      defer(load provider only when used) until one of the registered
      bindings is actually needed. Deferring the loading of such a provider
      will improve the performance of your application, since it's not
      loaded from the filesystem on every request
      Laravel compiles and stores a list of all it's services supplied by
      deferred service provider, along with the name of it's service
      provider class. Then , only when you attempt to resolve one of
      these services does laravel load the service provider
      To defer the loading of a provider, implement this contract:
      'Illuminate\Contracts\Support\DeferrableProvider' interface and
      define a provides() method. The provides() method should return
      the service container bindings registered by the service provider
      You can change your service provider and make compiled services
      change by:
      1. artisan command: 'php artisan clear-compiled'
      2. do some process stuff like running you application
       : 'php artisan serve' like that
